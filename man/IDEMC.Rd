% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idemc_generation.R
\name{IDEMC}
\alias{IDEMC}
\title{IDEMC Point Generation}
\usage{
IDEMC(
  xsamp,
  ems,
  targets,
  s,
  sn,
  p,
  imp = 3,
  all_specs = NULL,
  imps = NULL,
  ...
)
}
\arguments{
\item{xsamp}{The initial points}

\item{ems}{The emulators to evaluate implausibility over}

\item{targets}{The corresponding output targets}

\item{s}{The number of points to generate at each burn-in stage}

\item{sn}{The final number of points to generate}

\item{p}{The proportion of points kept at each stage of burn-in}

\item{imp}{The value of implausibility to stop the ladder at}

\item{all_specs}{If burn-in has already been performed, the cluster specifications}

\item{imps}{If burn-in has alreadt been performed, the implausibility laddder values}

\item{...}{Any additional parameters to pass to \code{IDEMC_step}}
}
\value{
A list of data.frames, corresponding to the points generated at each rung
}
\description{
Performs Implausibility-Driven Evolutionary Monte Carlo. Given a set of initial points
(preferably sampled across the full space), the implausibility ladder is set up via a burn-in
phase, before a full set of points is generated. This is a very compuationally intensive
procedure for generating points, and should be used only when the target space is expected
to be very small or have strange disconnected structure. For less awkward target spaces, use
any of the functionality in \code{\link{generate_new_runs}}.
}
\details{
The burn-in starts with a rung defined as the full space (i.e. any point whose implausibility
is less than the maximum implausibility over the space); from the sample of points it finds the
value of the implausibility such that the proportion of points in the new rung is \code{p} times
the number in the previous rung. It then uses these points to generate \code{s} new points at
the new rung using \code{IDEMC}. This continues until a desired lower rung is found (defined
by points whose implausibility is lower than \code{imp}).

Once the burn-in is performed, a full set of \code{sn} points is produced using this ladder.
}
\examples{
\dontrun{
ranges <- list(aSI = c(0.1, 0.8), aIR = c(0, 0.5), aSR = c(0, 0.05))
out_vars <- c('nS', 'nI', 'nR')
o_ems <- emulator_from_data(GillespieSIR, out_vars, ranges)
t_ems <- purrr::map(seq_along(o_ems), ~o_ems[[.]]$adjust(GillespieSIR, out_vars[[.]]))
z <- list(
 nS = list(val = 281, sigma = 10.43),
 nI = list(val = 30, sigma = 11.16),
 nR = list(val = 689, sigma = 14.32)
)
start_pts <- data.frame(
  aSI = runif(500, ranges$aSI[1], ranges$aSI[2]),
  aIR = runif(500, ranges$aIR[1], ranges$aIR[2]),
  aSR = runif(500, ranges$aSR[1], ranges$aSR[2])
)
result <- IDEMC(start_pts, t_ems, z, 50, 100, 0.3, imp = 2)
}

}
\references{
Vernon, I. & Williamson, D. (2013) Efficient uniform designs for multi-wave computer experiments. arXiv:1309.3520
}
\seealso{
[generate_new_runs()] for other point generation mechanisms.
}
