% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EmulatorDocumentation.R
\name{Emulator}
\alias{Emulator}
\title{Bayes Linear Emulator}
\description{
Creates an emulator object.

    The structure of the emulator is \code{f(x) = g(x) * beta + u(x)}, for
    regression functions \code{g(x)}, coefficients \code{beta}, and a correlation
    function \code{u(x)}. Can be used to create a new emulator via the Bayes
    Linear adjustment formulae.
}
\section{Constructor}{
 \code{Emulator$new(funcs = NULL, beta = NULL, u = NULL, betaucov = NULL)}
}

\section{Constructor Arguments}{

 \tabular{lll}{
  \strong{Argument} \tab \strong{Type} \tab \strong{Details} \cr
  \code{funcs} \tab list(closure) \tab A list of basis functions. \cr
  \code{beta} \tab list(mu = vector, sigma = matrix) \tab The specifications for the regression terms \code{beta}. \cr
  \code{u} \tab Correlator \tab The correlation structure. \cr
  \code{betaucov} \tab closure \tab Covariance function between beta and u. \cr
  \code{n_params} \tab numeric \tab If ranges not supplied, the number of input parameters. \cr
  \code{ranges} \tab list(numeric)|\code{NULL} \tab Parameter ranges. If none supplied, assumes all parameters are in [-1,1]. \cr
 }
}

\section{Constructor Details}{

    The constructor must take a list of vectorized basis functions, whose length is equal to
    the number of regression coeffcients. The regression specifications are given by the
    expectation of the betas (a length n vector) and a variance matrix (an nxn matrix).
    The correlation structure is encoded in a \code{\link{Correlator}} object.
    The covariance between beta and u can be left \code{NULL}, in which case zero covariance
    is assumed; otherwise an n-vector should be provided. Either the input parameter ranges
    are specified in \code{ranges}, or (if all parameters are in the range [-1,1]) the
    argument \code{n_inputs} should be supplied to indicate how many inputs we have.
}

\section{Public Methods}{

 \tabular{lll}{
  \strong{Accessor Methods} \tab \strong{Return} \tab \cr
  \code{get_exp} \tab Emulator expectation at a point \code{x}. \tab \cr
  \code{get_var} \tab Emulator variance at a point \code{x}. \tab \cr
  \strong{Object Methods} \tab \strong{Arguments} \tab \strong{Return} \cr
  \code{bayes_adjust} \tab \code{inputs = data.frame}; \code{outputs = data.frame} \tab A new emulator, whose properties are determined from the Bayes linear adjustment of the current emulator. \cr
  \code{implausibility} \tab \code{x = numeric}; \code{z = list(val=numeric, sigma=numeric)|numeric} \tab Finds the implausiblity of an observation \code{z} at a point \code{x}. \cr
 }
}

\examples{
    # Simple regression surface: no variance, two dimensional parameter space
    # A system like this could be obtained from, eg, lm or step
    regression_specifications = list(mu = c(0.1, 0.2, -0.1), sigma = diag(0, nrow=3))
    basis_functions = c(function(x) 1, function(x) x[[1]], function(x) x[[2]])
    # Specifications for the correlation structure:
    # E[x]=0 for all x, and Cov[u(x),u(x')]=0.36*exp_sq(...,0.1)
    u_exp <- function(x) 0
    u_cov <- function(x, xp) 0.36 * exp_sq(x, xp, 0.1)
    correlation_structure = Correlator$new(u_cov, u_exp)
    # The next line isn't necessary - if bucov is not specified,
    # the mixed covariance is assumed to be zero
    mixed_covariance = function(x) rep(0, length(regression_specifications$mu))
    em = Emulator$new(funcs = basis_functions, beta = regression_specifications,
        u = correlation_structure, bucov = mixed_covariance, n_inputs = 2)
    em$get_exp(c(1,-1))
    #> 0.4
    em$get_var(c(1,-1))
    #> 0.36
    # Define input and output points on which to train the emulator
    # (here x and y are the inputs, and z the output)
    data <- data.frame(x = c(1, 2, 3), y = c(-1, 2, 1), z = c(0.1, 0.3, -0.3))
    # Alternative to the below line is to refer by column names.
    # Easier if the structure of the data frame is unclear
    newem <- em$bayes_adjust(data[,c(1,2)], data[,3])
    # New emulator is trained to data points: the expectation at the data points
    # matches with z, and the variance at these points is 0
    newem$get_exp(c(1,-1))
    #> 0.1
    newem$get_var(c(1,-1))
    #> 0
}
