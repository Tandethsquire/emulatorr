% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EmulatorDocumentation.R
\name{Emulator}
\alias{Emulator}
\title{Bayes Linear Emulator}
\description{
Creates an emulator object.

    The structure of the emulator is \code{f(x) = g(x) * beta + u(x)}, for
    regression functions \code{g(x)}, coefficients \code{beta}, and a correlation
    function \code{u(x)}. Can be used to create a new emulator via the Bayes
    Linear adjustment formulae.
}
\section{Constructor}{
 \code{Emulator$new(funcs = NULL, beta = NULL, u = NULL, betaucov = NULL)}
}

\section{Arguments}{

 \code{funcs} A list of basis functions to be used. For ease of understanding, it is advisable
 to arrange these in increasing powers of the variables, with the constant function as the
 first element (this is the format outputted by \code{\link{emulator_from_data}}).

 \code{beta} Specifications for the regression parameters, in the form \code{list(mu, sigma)}.
 \code{mu} is a vector of coefficients, and \code{sigma} is the corresponding covariance matrix.

 \code{u} A suitably specified \code{\link{Correlator}} object.

 \code{betaucov} The covariance between \code{beta} and \code{u}, as a vector of length
 \code{length(beta$mu)}.

 \code{n_params} Only required if parameter ranges are not supplied: the dimension of the
 input parameter space.

 \code{ranges} A (named) list of parameter ranges; that is, a list of the form
 \code{list(a = c(0,1), b = c(1, 2), ...)}.
}

\section{Constructor Details}{


    The constructor must take a list of vectorized basis functions, whose length is equal to
    the number of regression coeffcients. The regression specifications are given by the
    expectation of the betas (a length n vector) and a variance matrix (an nxn matrix).
    The correlation structure is encoded in a \code{\link{Correlator}} object.
    The covariance between beta and u can be left \code{NULL}, in which case zero covariance
    is assumed; otherwise an n-vector should be provided. Either the input parameter ranges
    are specified in \code{ranges}, or (if all parameters are in the range [-1,1]) the
    argument \code{n_inputs} should be supplied to indicate how many inputs we have.
}

\section{Accessor Methods}{


 \code{get_exp(x)} Returns the emulator expectation at a point \code{x}.

 \code{get_cov(x, xp = NULL)} Returns the emulator covariance between two points
 \code{x} and \code{xp}. If only \code{x} is supplied, the variance of the emulator
 at \code{x} is returned.

 \code{implausibility(x, z)} Returns the implausibility that an input point \code{x}
 gives rise to output \code{z}. The point \code{z} can be supplied in two ways:
 as a named list \code{list(val = , sigma = )} corresponding to observation value
 and uncertainty, respectively. If \code{z} is supplied as a single numeric, then
 the measurement uncertainty is assumed to be 0 (tread with care here!)
}

\section{Object Methods}{


 \code{bayes_adjust(inputs, outputs)} Performs Bayes Linear Adjustment on the
 emulator, given input points \code{inputs} and output values \code{outputs}. Returns
 a new Emulator object with prior specifications given by the original emulator,
 trained on the points given.
}

\examples{
    # Simple regression surface: no variance, two dimensional parameter space
    # A system like this could be obtained from, eg, lm or step
    regression_specifications = list(mu = c(0.1, 0.2, -0.1), sigma = diag(0, nrow=3))
    basis_functions = c(function(x) 1, function(x) x[[1]], function(x) x[[2]])
    # Specifications for the correlation structure:
    # E[x]=0 for all x, and Cov[u(x),u(x')]=0.36*exp_sq(...,0.1)
    u_exp <- function(x) 0
    u_cov <- function(x, xp) 0.36 * exp_sq(x, xp, 0.1)
    correlation_structure = Correlator$new(u_cov, u_exp)
    # The next line isn't necessary - if bucov is not specified,
    # the mixed covariance is assumed to be zero
    mixed_covariance = function(x) rep(0, length(regression_specifications$mu))
    em = Emulator$new(funcs = basis_functions, beta = regression_specifications,
        u = correlation_structure, bucov = mixed_covariance, n_inputs = 2)
    em$get_exp(c(1,-1))
    #> 0.4
    em$get_cov(c(1,-1))
    #> 0.36
    # Define input and output points on which to train the emulator
    # (here x and y are the inputs, and z the output)
    data <- data.frame(x = c(1, 2, 3), y = c(-1, 2, 1), z = c(0.1, 0.3, -0.3))
    # Alternative to the below line is to refer by column names.
    # Easier if the structure of the data frame is unclear
    newem <- em$bayes_adjust(data[,c(1,2)], data[,3])
    # New emulator is trained to data points: the expectation at the data points
    # matches with z, and the variance at these points is 0
    newem$get_exp(c(1,-1))
    #> 0.1
    newem$get_cov(c(1,-1))
    #> 0
}
