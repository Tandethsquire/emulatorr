% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/emulator_from_data.R
\name{emulator_from_data}
\alias{emulator_from_data}
\title{Create Bayes Linear emulators from data}
\usage{
emulator_from_data(
  input_data,
  input_names,
  output_names,
  ranges,
  beta,
  u,
  c_lengths,
  funcs,
  bucov
)
}
\arguments{
\item{input_data}{Required. A dataframe containing the input parameters and output values from a set of simulator runs.}

\item{input_names}{Required. Indicates which columns of \code{input_data} are the inputs.}

\item{output_names}{Required. Indicates which columns of \code{input_data} are the outputs.}

\item{ranges}{The input parameter ranges, as a list of 2-vectors.}

\item{beta}{Optional. Specifications for regression coefficients; each in the form \code{list(mu = vector, sigma = matrix)} per output.}

\item{u}{Optional. Specifications for correlation structure; each in the form \code{list(sigma = numeric, mu = closure, theta = numeric, corr = closure)}}

\item{c_lengths}{Optional if \code{ranges} or a full \code{u} specification is provided. Correlation lengths for each output.}

\item{funcs}{Optional. Basis functions for the regression surface.}

\item{bucov}{Optional. Covariance vector between beta and u.}
}
\value{
A list of objects of class \code{\link{Emulator}}.
}
\description{
Given simulator data, generates a set of emulators.
}
\details{
Many of the parameters passed to the function are optional; if they are not
provided, a linear model is fitted as follows:

The basis functions are assumed to be (1, x1, x2, ...) for inputs x1, x2, ...

The associated beta parameters for each output are found from the coefficients of
step(lm(output~x1+x2+...)).
They are assumed to be known, and so given a variance matrix 0.

The correlation structire is taken to be exponential squared, with correlation length one-sixth
of the input parameter range. The overall variance is taken to be the residual squared error
from the linear models used to fit the regression coefficients, and zero expectation is assumed.

The covariance between the regression coefficients and the correlation structure is assumed to
be 0 (passed as \code{NULL} into the emulator).
}
\examples{
    inputdata <- GillespieSIR
    in_vars <- c("aSI", "aIR", "aSR")
    out_vars <- c("nS", "nI", "nR")
    ranges <- list(c(0.1, 0.8), c(0, 0.5), c(0, 0.05))
    emulators <- emulator_from_data(input_data = inputdata, input_names = in_vars,
     output_names = out_vars, ranges = ranges, c_lengths = c(0.1, 0.085, 0.075))
    emulators[[1]]$get_exp(c(0.4,0.25,0.025))
    #> 341.8855
    emulators[[1]]$get_var(c(0.4,0.25,0.025))
    #> 8939.337
    # Now we can actually use the data to generate useful emulators
    new_emulators <- purrr::map(seq_along(emulators),
        ~emulators[[.x]]$bayes_adjust(inputdata[,in_vars], inputdata[,out_vars[[.x]]]))
    new_emulators[[1]]$get_exp(c(0.4,0.25,0.025))
    #> 367.8078
    new_emulators[[1]]$get_var(c(0.4,0.25,0.025))
    #> 679.3054

    # Same data as above, but with custom specifications.
    # Suppose we instead use GLS estimates of the betas, and they're known:
    beta_sigma <- diag(0, nrow=4)
    beta_specs <- list(
     list(mu = c(508.8783, -616.2146, 863.3770, -5616.7661), sigma = beta_sigma),
     list(mu = c(287.0726, 251.0185, -1029.0808, -705.5883), sigma = beta_sigma),
     list(mu = c(183.7949, 429.8564, 191.6515, 6058.9556), sigma = beta_sigma)
    )
    u_mu <- function(x) 0
    correlators <- list(
     list(sigma = 94.548, mu = u_mu, theta = 0.1, corr = exp_sq),
     list(sigma = 113.299, mu = u_mu, theta = 0.085, corr = exp_sq),
     list(sigma = 144.198, mu = u_mu, theta = 0.075, corr = exp_sq)
    )
    emulators <- emulator_from_data(input_data = GillespieSIR, input_names = in_vars,
     output_names = out_vars, beta = beta_specs, u = correlators, ranges = ranges)

}
