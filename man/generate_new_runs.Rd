% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gennewruns.R
\name{generate_new_runs}
\alias{generate_new_runs}
\title{Generate Simulator Runs}
\usage{
generate_new_runs(
  emulators,
  ranges,
  n_points = 10 * length(ranges),
  z,
  method = "importance",
  include_line = TRUE,
  cutoff = 3,
  plausible_set,
  burn_in = FALSE,
  ...
)
}
\arguments{
\item{emulators}{A list of \code{\link{Emulator}} objects, trained on the design points}

\item{ranges}{The ranges of the input parameters}

\item{n_points}{Optional. Specifies how many additional points are required. Default: 10*(number of emulators)}

\item{z}{Checks implausibility of sample points to restrict to only non-implausible points.}

\item{method}{Any of 'lhs', 'slice', 'optical'.}

\item{include_line}{Should line sampling be applied after point generation? Default: TRUE.}

\item{cutoff}{Optional. If z is given, this is the implausibility cutoff for the filtering. Default = 3}

\item{plausible_set}{Optional - a set of non-implausible points from which to start.}

\item{burn_in}{If importance sampling, should a burn-in phase be used? Default: FALSE}

\item{...}{Any parameters that need to be passed to a particular method (see below)}
}
\value{
A \code{data.frame} containing the set of new points to simulate at.
}
\description{
A wrapper for a variety of sampling methods.
Given a set of trained emulators, finds the next set of points that will be informative
for the next wave of emulators.
}
\details{
If the method is 'lhs', this creates a new training set using LHS, and
then finds the trace of the variance matrix of the emulators across these points (this is
broadly equivalent to using V-optimality). We repeat this for \code{n_runs}, and select
the configuration that minimises the mean of the variances across the emulators.
If observations are given, then these are used to ensure that the new sample points are
non-implausible according to the current emulators.

If the method is 'slice', then an initial point \code{x} must be provided. This is ideally
an non-implausible point, or at least one close to the suspected non-implausible region.
It then applies slice sampling, using implausibility as a measure of success.

If the method is 'optical', then the optical depth of the space in each parameter direction
is calculated (using a known set of non-implausible points \code{plausible_set}),
and used as a distribution for that parameter. Points are sampled from the
collection of distributions and non-implausible points generated are filtered out. From the
remaining points, a sample of the required size is generated using maximin criterion.

If the method is 'importance', importance sampling is used. Starting from a set of
non-implausible (preferably space-filling) points, points are sampled from a distribution
around the points, and included in the output based on a weighted measure gained from the
mixture distribution of the initial points. The set \code{plausible_set} must be specified.
If \code{burn_in} is TRUE, then a burn-in phase is used to determine the optimal parameters
for the proposal distribution.

Note that the \code{plausible_set} parameter size differs between the two methods that use
it (the 'optical' and 'importance') methods. The optical set should be as large as possible
in order to accurately represent the optical depth in each parameter direction; the set for
importance sampling should be smaller (and probably smaller than the desired number of
output points) in order to expedite the initial set-up of the sampling strategy.

For any sampling strategy, the parameters \code{emulators}, \code{ranges} and
\code{z} must be specified. If the method is 'slice', then the parameter \code{x}
is necessary. All other parameters are optional.

After the first round of sampling, if \code{line_sample} is enabled, an exploration of the
boundary of the non-implausible region is performed as follows. Two points are chosen at
random, and a number of points are sampled uniformly along the line connecting these points.
The sampled points are tested for implausibility, and (provided more than 50% but not all
of the points are non-implausible) the most separated of the points replace the two initial
points.
}
\examples{
ranges <- list(aSI = c(0.1, 0.8), aIR = c(0, 0.5), aSR = c(0, 0.05))
ems <- emulator_from_data(GillespieSIR, output_names = c('nS', 'nI', 'nR'),
 ranges = ranges, quadratic = TRUE)
trained_ems <- purrr::map(seq_along(ems),
 ~ems[[.x]]$adjust(GillespieSIR, c('nS', 'nI', 'nR')[[.x]]))
targets <- list(
 list(val = 281, sigma = 10.43),
 list(val = 30, sigma = 11.16),
 list(val = 689, sigma = 14.32)
)
non_imp_points <- GillespieImplausibility[GillespieImplausibility$I <= 4, names(ranges)]
example_point <- unlist(non_imp_points[sample(1:length(non_imp_points[,1]), 1),],
 use.names = FALSE)
pts_lhs <- generate_new_runs(trained_ems, ranges, 10, targets, cutoff = 3)
#pts_slice <- generate_new_runs(trained_ems, ranges, 10, targets,
 #method = 'slice', cutoff = 4, x = example_point)
pts_optical <- generate_new_runs(trained_ems, ranges, 10, targets,
 method = 'optical', cutoff = 4, plausible_set = non_imp_points)
non_imp_sample <- non_imp_points[sample(seq_along(non_imp_points[,1]), 20),]
pts_importance <- generate_new_runs(trained_ems, ranges, 10, targets,
 method = 'importance', cutoff = 4, plausible_set = non_imp_sample, include_line = FALSE)
}
