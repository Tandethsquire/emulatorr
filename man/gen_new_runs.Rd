% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gennewruns.R
\name{gen_new_runs}
\alias{gen_new_runs}
\title{Generate Simulator Runs}
\usage{
gen_new_runs(
  old_points,
  emulators,
  ranges,
  n_points = 10 * length(emulators),
  n_runs = 100
)
}
\arguments{
\item{old_points}{A \code{data.frame} containing the original design points.}

\item{emulators}{A list of \code{\link{Emulator}} objects, trained on the design points}

\item{ranges}{The ranges of the input parameters}

\item{n_points}{Optional. Specifies how many additional points are required. Default: 10*(number of emulators)}

\item{n_runs}{Optional. Number of sampling runs to perform. Default = 100}
}
\value{
A \code{data.frame} containing the set of new points to simulate at.
}
\description{
Given a set of trained emulators, finds the next set of points that will be informative
for the next wave of emulators. It first augments the current training set using LHS, and
then finds the trace of the variance matrix of the emulators across these points (this is
broadly equivalent to using V-optimality). We repeat this for \code{n_runs}, and select
the configuration that minimises the mean of the variances across the emulators.
}
\examples{
   emulators <- emulator_from_data(input_data = GillespieSIR,
    input_names = c('aSI','aIR','aSR'), output_names = c('nS','nI','nR'),
    c_lengths = c(0.1, 0.085, 0.075))
   trained_emulators <- purrr::map(seq_along(emulators),
    ~emulators[[.x]]$bayes_adjust(GillespieSIR[,c('aSI','aIR','aSR')],
    GillespieSIR[,c('nS','nI','nR')[[.x]]]))
   gen_new_runs(GillespieSIR[,c('aSI','aIR','aSR')], trained_emulators,
    list(c(0.1, 0.8), c(0, 0.5), c(0, 0.05)), n_points = 5, n_runs = 10)
}
